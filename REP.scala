package com.rockthejvm

import scala.util.Random
import scala.io.Source
import java.time.{Instant, LocalDateTime, ZoneId, ZoneOffset}
import java.io.File
import com.github.tototoshi.csv._
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import scala.util.Try
//import java.time.ZoneOffset

case class SolarPanel(id: Int, orientation: Int, tilt: Int)
case class WindTurbine(id: Int, bladelength: Int, rotorDiameter: Int)
case class HydroPower(id: Int, waterFlowRate: Int, head: Int)

object REP extends App{
  //Creating a CSV file which stores power plant configuration data
  case class PowerPlantConfig(name: String,minCapacity: Double, maxCapacity: Double)

  //Defining the power plant configuration data
  val configData = List(
    PowerPlantConfig("Solar Panel",100000.0,10000000.0),
    PowerPlantConfig("Wind Turbine",3000000.0, 30000000.0),
    PowerPlantConfig("Hydro Power",1000000.0, 30000000.0)
  )

  //Writing the power plant configuration data to CSV file
  val file = new File("Power_plant_Config.csv")
  val writer = CSVWriter.open(file)
  writer.writeRow(List("Name", "Min Capacity (MW)","Max Capacity (MW)"))
  configData.foreach(c => writer.writeRow(List(c.name,c.minCapacity, c.maxCapacity)))
  writer.close()

  //Case 1: Monitoring and Controlling the power plant's renewable energy sources
  trait RenewableEnergySource {
    def id: Int
    def energyOutput: Double
  }
  object SolarPanel {
    val maxEnergyOutput: Double = 100.0 //kW per panel
  }

  case class SolarPanel(id:Int, orientation: Int, tilt: Int) extends RenewableEnergySource {
    override def energyOutput: Double = {
      SolarPanel.maxEnergyOutput * orientation * tilt
    }
  }

  object WindTurbine {
    val maxEnergyOutput: Double = 1000.0 //kW per turbine
  }

  case class WindTurbine(id: Int, bladeLength: Int, rotorDiameter: Int) extends RenewableEnergySource {
    override def energyOutput: Double = {
      WindTurbine.maxEnergyOutput * bladeLength * rotorDiameter
    }
  }

  object Hydropower {
    val maxEnergyOutput: Double = 5000.0 //kW per unit
  }

  case class Hydropower (id: Int, waterFlowRate: Int, head: Int) extends RenewableEnergySource {
    override def energyOutput: Double = {
      Hydropower.maxEnergyOutput * waterFlowRate * head
    }
  }

  val renewableEnergySources = List(
    SolarPanel(1,90,30),
    SolarPanel(2,45,20),
    SolarPanel(3,40,50),
    SolarPanel(4,60,90),
    SolarPanel(5,30,10),
    SolarPanel(6,50,40),
    SolarPanel(7,60,30),
    SolarPanel(8,90,70),
    WindTurbine(1,45,55),
    WindTurbine(2,56,48),
    WindTurbine(3,67,56),
    WindTurbine(4,120,60),
    WindTurbine(5,60,90),
    WindTurbine(6,80,40),
    WindTurbine(7,40,100),
    WindTurbine(8,40,100),
    WindTurbine(9,40,100),
    Hydropower(1,15,27),
    Hydropower(2,34,45),
    Hydropower(3,23,45),
    Hydropower(4,25,40),
    Hydropower(5,20,34),
    Hydropower(6,25,35),
    Hydropower(7,30,50),
    Hydropower(8,1,70),
    Hydropower(9,8,60),
    Hydropower(10,5,25)
  )

  def totalEnergyOutput(sources: List[RenewableEnergySource]): Double = {
    sources.foldLeft(0.0)(_ + _.energyOutput)
  }

  //Case Two: Storing energy generated by renewable sources in a file

  case class EnergyDataPoint(timestamp: Long,id: Int, energyOutput: Double)

  def storeEnergyDataToFile(filename: String, energyData: List[EnergyDataPoint]): Unit = {
    val file = new File(filename)
    val writer = CSVWriter.open(file)
    writer.writeRow(List("ID","timestamp","Energy_output"))

    val currentDateTime = LocalDateTime.now()
    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
    val formattedDateTime = currentDateTime.format(formatter)


    energyData.foreach(dataPoint => writer.writeRow(List(dataPoint.id.toString,formattedDateTime.toString, dataPoint.energyOutput.toString)))
    writer.close()
  }
  val solarPanelEnergyData = renewableEnergySources.collect {case s: SolarPanel => EnergyDataPoint(System.currentTimeMillis(),s.id, s.energyOutput)}.toList
  storeEnergyDataToFile("Solar_Panel.csv",solarPanelEnergyData)

  val windTurbineEnergyData = renewableEnergySources.collect {case s: WindTurbine => EnergyDataPoint(System.currentTimeMillis(),s.id,s.energyOutput)}.toList
  storeEnergyDataToFile("Wind_Turbine.csv", windTurbineEnergyData)

  val hydroPowerEnergyData = renewableEnergySources.collect {case s: Hydropower => EnergyDataPoint(System.currentTimeMillis(),s.id, s.energyOutput)}.toList
  storeEnergyDataToFile("Hydro_Power.csv",hydroPowerEnergyData)

  //Case 3: Viewing the data stored in the file

  case class EnergyData(id: Int, timestamp: String, energyOutput: Double)

  val solarPanelData = readEnergyDataFromFile("Solar_Panel.csv")
  val windTurbineData = readEnergyDataFromFile("Wind_Turbine.csv")
  val hydroPowerData = readEnergyDataFromFile("Hydro_Power.csv")

  println("Solar Panel Energy Generation:")
  printEnergyData(solarPanelData)

  println("\nWind Turbine Energy Generation:")
  printEnergyData(windTurbineData)

  println("\nHydro Power Energy Generation:")
  printEnergyData(hydroPowerData)

  //Function to read energy data from CSV file
  def readEnergyDataFromFile(filename: String): Either[String, List[EnergyData]] = {
    Try {
      val file = new File(filename)
      val reader = CSVReader.open(file)
      val data = reader.allWithHeaders()
      reader.close()

      //Mapping the CSV rows to EnergyData objects
      data.map(row => EnergyData(row("ID").toInt,row("timestamp"),row("Energy_output").toDouble)).toList
    }.toEither.left.map(_.getMessage) //Coverting any exception to a left containing an error message
  }

  //Function to print energy data
  def printEnergyData(energyData: Either[String, List[EnergyData]]): Unit = {
    energyData match {
      case Left(errorMessage) => println(s"Error: $errorMessage") //Print error message if there was an error reading the data
      case Right(data) =>
        //Printing column headers and data if there were no errors
      println("ID\tTimestamp\t\t\t\tEnergy Output")
        data.foreach(d => println(s"${d.id}\t${d.timestamp}\t\t${d.energyOutput}"))

    }
  }

  //Reading power plant configuration data from CSV file
  val powerPlantConfig = readPowerPlantConfigFromFile("Power_plant_Config.csv")

  //Printing power plant configuration data
  println("\nPower Plant Configuration:")
  printPowerPlant(powerPlantConfig)

  //Functionality for viewing storage capacity of power plants
  //Function to read power plant configuration data from CSV file
  def readPowerPlantConfigFromFile(filename: String): Either[String, List[PowerPlantConfig]] = {
    //Using Try to handle exception when reading the file
    Try {
      val file = new File(filename)
      val reader = CSVReader.open(file)
      val data = reader.allWithHeaders()
      reader.close()

      //Maping the CSV rows to PowerPlantConfig objects
      data.map(row => PowerPlantConfig(row("Name"),row("Min Capacity (MW)").toDouble,row("Max Capacity (MW)").toDouble)).toList
    }.toEither.left.map(_.getMessage) //Converts any exception to a left containing an error message
  }
      //Function to print power plant configuration data
      def printPowerPlant(powerPlantConfig: Either[String, List[PowerPlantConfig]]): Unit = {
        powerPlantConfig match {
          case Left(errorMessage) => println(s"Error: $errorMessage") //Prints error message if there was an error reading the data
          case Right(data) =>
            //Print column headers and data if there were no errors
            println("Name\t\tMin Capacity (MW)\t\tMax Capacity (MW)")
            data.foreach(c => println(s"${c.name}\t\t${c.minCapacity}\t\t\t${c.maxCapacity}"))
        }
      }

  //Case 4: Data Analysis and data filtering
  case class EnergyDataAnalysis(timestamp: LocalDateTime, energyOutput: Double)

  def readEnergyGeneratedFromFile(filename: String): List[EnergyDataAnalysis] = {
    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
    val fileSource = Source.fromFile(filename)
    val lines = fileSource.getLines().toList.drop(1)
    val dataPoints = lines.map(line => {
      val Array(id,timestamp, energyOutput) = line.split(",")
      EnergyDataAnalysis(LocalDateTime.parse(timestamp,formatter),energyOutput.toDouble)
    })
    fileSource.close()
    dataPoints
  }

  def filterByHour(data:List[EnergyDataAnalysis]): Map[Int, Double] = {
    val hourToEnergyOutput = data.groupBy(_.timestamp.getHour).mapValues(_.map(_.energyOutput).sum)
    hourToEnergyOutput.toSeq.sortBy(_._1).toMap
  }

  def filterByDay(data: List[EnergyDataAnalysis]): Map[Int, Double] = {
    val dayToEnergyOutput = data.groupBy(_.timestamp.getDayOfMonth).mapValues(_.map(_.energyOutput).sum)
    dayToEnergyOutput.toSeq.sortBy(_._1).toMap
  }

  def filterByMonth(data: List[EnergyDataAnalysis]): Map[Int, Double] = {
    val monthToEnergyOutput = data.groupBy(_.timestamp.getMonthValue).mapValues(_.map(_.energyOutput).sum)
    monthToEnergyOutput.toSeq.sortBy(_._1).toMap
  }

  def filterByWeek(data: List[EnergyDataAnalysis]): Map[Int, Double] = {
    val weekToEnergyOutput = data.groupBy(_.timestamp.getDayOfYear / 7).mapValues(_.map(_.energyOutput).sum)
    weekToEnergyOutput.toSeq.sortBy(_._1).toMap
  }

  def mean(data: List[EnergyDataAnalysis]): Double = {
    data.map(_.energyOutput).sum / data.length
  }

  def median(data: List[EnergyDataAnalysis]): Double = {
    val sortedData = data.map(_.energyOutput).sorted
    if (sortedData.length % 2 == 0) {
      (sortedData(sortedData.length/2 -1) + sortedData(sortedData.length/2)) / 2.0
    } else {
      sortedData(sortedData.length/2)
    }
  }

  def mode(data: List[EnergyDataAnalysis]): Double = {
    val energyOutputToCount = data.groupBy(_.energyOutput).mapValues(_.length)
    val maxCount = energyOutputToCount.values.max
    val modes = energyOutputToCount.filter(_._2 == maxCount).keys
    if (modes.size == 1) {
      modes.head
    } else {
      throw new RuntimeException("There is no unique mode")
    }
  }

  def range(data: List[EnergyDataAnalysis]): Double = {
    val energyOutputs = data.map(_.energyOutput)
    energyOutputs.max - energyOutputs.min
  }

  def midRange(data: List[EnergyDataAnalysis]): Double = {
    val energyOutputs = data.map(_.energyOutput)
    (energyOutputs.max + energyOutputs.min) / 2.0
  }

  //Analysing the data collected from Solar Panels
  val data = readEnergyGeneratedFromFile("Solar_Panel.csv")
  val meanValue = mean(data)
  val medianValue = median(data)
  val modeValue = mode(data)
  val rangeValue = range(data)
  val midRangeValue = midRange(data)

  println("\nData Analysis for Solar Panels:")
  println(s"Mean: $meanValue")
  println(s"Median: $medianValue")
  println(s"Mode: $modeValue")
  println(s"Range: $rangeValue")
  println(s"Mid-Range: $midRangeValue")

  //Analysing the data collected from Wind Turbines
  val data1 = readEnergyGeneratedFromFile("Wind_Turbine.csv")
  val meanValue1 = mean(data1)
  val medianValue1 = median(data1)
  val modeValue1 = mode(data1)
  val rangeValue1 = range(data1)
  val midRangeValue1 = midRange(data1)

  println("\nData Analysis for Wind Turbines:")
  println(s"Mean: $meanValue1")
  println(s"Median: $medianValue1")
  println(s"Mode: $modeValue1")
  println(s"Range: $rangeValue1")
  println(s"Mid-Range: $midRangeValue1")

  //Analysing the data collected from Hydro Power
  val data2 = readEnergyGeneratedFromFile("Wind_turbine.csv")
  val meanValue2 = mean(data2)
  val medianValue2 = median(data2)
  val modeValue2 = mode(data2)
  val rangeValue2 = range(data2)
  val midRangeValue2 = midRange(data2)

  println("\nData Analysis for Hydro Powers:")
  println(s"Mean: $meanValue2")
  println(s"Median: $medianValue2")
  println(s"Mode: $modeValue2")
  println(s"Range: $rangeValue2")
  println(s"Mid-Range: $midRangeValue2")

  //Filtering data for Solar Panels
  val energyData = readEnergyGeneratedFromFile("Solar_Panel.csv")
  val energyByHour = filterByHour(energyData)
  val energyByDay = filterByDay(energyData)
  val energyByWeek = filterByWeek(energyData)
  val energyByMonth = filterByMonth(energyData)
  println("\nFiltering data for Solar Panel:")
  println("Energy output by hour:")
  energyByHour.foreach{ case (hour, energyOutput) => println(s"$hour:00 - $energyOutput")}
  println("Energy output by day:")
  energyByDay.foreach { case (day, energyOutput) => println(s"$day - $energyOutput") }
  println("Energy output by week:")
  energyByWeek.foreach { case (week, energyOutput) => println(s"$week - $energyOutput") }
  println("Energy output by month:")
  energyByMonth.foreach { case (month, energyOutput) => println(s"$month - $energyOutput") }

  //Filtering data for Wind Turbine
  val energyData1 = readEnergyGeneratedFromFile("Wind_Turbine.csv")
  val energyByHour1 = filterByHour(energyData1)
  val energyByDay1 = filterByDay(energyData1)
  val energyByWeek1 = filterByWeek(energyData1)
  val energyByMonth1 = filterByMonth(energyData1)
  println("\nFiltering data for Wind Turbine:")
  println("Energy output by hour:")
  energyByHour1.foreach { case (hour, energyOutput) => println(s"$hour:00 - $energyOutput") }
  println("Energy output by day:")
  energyByDay1.foreach { case (day, energyOutput) => println(s"$day - $energyOutput") }
  println("Energy output by week:")
  energyByWeek1.foreach { case (week, energyOutput) => println(s"$week - $energyOutput") }
  println("Energy output by month:")
  energyByMonth1.foreach { case (month, energyOutput) => println(s"$month - $energyOutput") }

  //Filtering data for Hydro Power
  val energyData2 = readEnergyGeneratedFromFile("Hydro_Power.csv")
  val energyByHour2 = filterByHour(energyData2)
  val energyByDay2 = filterByDay(energyData2)
  val energyByWeek2 = filterByWeek(energyData2)
  val energyByMonth2 = filterByMonth(energyData2)
  println("\nFiltering data for Hydro Power:")
  println("Energy output by hour:")
  energyByHour2.foreach { case (hour, energyOutput) => println(s"$hour:00 - $energyOutput") }
  println("Energy output by day:")
  energyByDay2.foreach { case (day, energyOutput) => println(s"$day - $energyOutput") }
  println("Energy output by week:")
  energyByWeek2.foreach { case (week, energyOutput) => println(s"$week - $energyOutput") }
  println("Energy output by month:")
  energyByMonth2.foreach { case (month, energyOutput) => println(s"$month - $energyOutput") }

  //Case 5: Detecting and handling issues

  case class PowerPlantConfig1(name: String, minCapacity: Double, maxCapacity: Double)

  def readPowerPlantConfig(filePath: String): List[PowerPlantConfig1] = {
    val source = Source.fromFile(filePath)
    val lines = source.getLines().toList.tail //Skip header row
    source.close()

    lines.map { line =>
      val cols = line.split(",").map(_.trim)
      PowerPlantConfig1(cols(0), cols(1).toDouble, cols(2).toDouble)
    }
  }

  def readEnergyOutput(filePath: String): List[(String, Double)] = {
    val source = Source.fromFile(filePath)
    val lines = source.getLines().toList.tail //Skip header row
    source.close()

    lines.map { line =>
      val cols = line.split(",").map(_.trim)
      (cols(0), cols(2).toDouble)
    }
  }

  def isLowEnergyOutput(powerPlant: PowerPlantConfig1, currentOutput: Double): Boolean = {
    currentOutput < powerPlant.minCapacity
  }

  //Reading power plant configs from file
  val powerPlantConfig1 = readPowerPlantConfig("Power_Plant_Config.csv")

  println("\nEnergy Output is low for the following solar panels:")
  //Reading current energy outputs from file
  val solarPanelOutputs = readEnergyOutput("Solar_Panel.csv")
  val lowOutputs = solarPanelOutputs.filter { case (id, output) =>
    val low = isLowEnergyOutput(powerPlantConfig1.head, output)
    if (low) {
      println(s"ID$id - $output")
    }
    low
  }

  println("\nEnergy Output is low for the following wind turbines:")
  //Reading current energy outputs from Wind_Turbine.csv
  val windTurbineOutputs = readEnergyOutput("Wind_Turbine.csv")
  val lowOutputs1 = windTurbineOutputs.filter { case (id, output) =>
    val low1 = isLowEnergyOutput(powerPlantConfig1(1), output)
    if (low1) {
      println(s"ID$id - $output")
    }
    low1
  }

  println("\nEnergy Output is low for the following hydro powers:")
  //Reading current energy outputs from Hydro_Power.csv
  val hydroPowerOutputs = readEnergyOutput("Hydro_Power.csv")
  val lowOutputs2 = hydroPowerOutputs.filter { case (id, output) =>
    val low2 = isLowEnergyOutput(powerPlantConfig1(2), output)
    if (low2) {
      println(s"ID$id - $output")
    }
    low2
  }
  }
